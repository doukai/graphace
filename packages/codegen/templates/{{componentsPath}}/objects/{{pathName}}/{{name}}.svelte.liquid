<script lang="ts">
	import { createEventDispatcher, getContext } from 'svelte';
	import type { Readable } from 'svelte/store';
	import { fade } from 'svelte/transition';
	import { createPopover, melt } from '@melt-ui/svelte';
	import { Icon } from '@steeze-ui/svelte-icon';
	import { AdjustmentsHorizontal, Funnel, Bookmark } from '@steeze-ui/heroicons';
	import { type PermissionsStore } from '@graphace/commons';
	import { type Field } from '@graphace/graphql';
	import { Combobox, type Group as G, Pagination, type Option } from '@graphace/ui';
	import {{ name }}Filter from '~/{{ objectsPath }}/{{ name | paramCase }}/{{ name }}Filter.svelte';
	import type { {{ name }}ConnectionQueryArguments } from '~/{{ schemaTypesPath }}';
	import type { TranslationFunctions } from '$i18n/i18n-types';
	import { getIdFieldName } from '~/utils';
	
	export let fields: Field[] = [];
	export let queryFields: Field[] = [];
	export let queryArguments: {{ name }}ConnectionQueryArguments = {};
	export let selectColumns: Option[] = [];
	export let join: Option | undefined = undefined;
	export let joinColumns: Option[] = [];
	export let orderByColumns: Option[] = [];
	export let totalCount: number = 0;
	export let pageNumber: number = 1;
	export let pageSize: number = 10;
	export let isFetching: boolean = false;
	export let showHeader: boolean = true;
	export let showFooter: boolean = true;
	export let showOptionButton: boolean = true;
	export let showFilterButton: boolean = true;
	export let showBookmarkButton: boolean = false;
	export let className: string = '';

	const LL = getContext('LL') as Readable<TranslationFunctions>;
	const permissions = getContext('permissions') as PermissionsStore;
	const typeName = '{{ name }}';
	
	const dispatch = createEventDispatcher<{
		query: { fields: Field[]; queryArguments: {{ name }}ConnectionQueryArguments };
		bookmark: { fields: string; queryArguments: string };
	}>();

	const {
		elements: { trigger, content, arrow, close, overlay },
		states: { open }
	} = createPopover({
		forceVisible: true,
		preventScroll: true
	});

	$: selectOptions = [
		{
			value: '',
			label: $LL.graphql.objects.{{ name }}.name(),
			options: [
				{%- for leafField in leafFields %}
				{
					value: '{{ leafField.fieldName }}',
					label: $LL.graphql.objects.{{ name }}.fields.{{ leafField.fieldName }}.name(),
					{%- if useAuth %}
					disabled: !permissions.auth('{{ name }}::{{ leafField.fieldName }}::READ')
					{%- endif %}
				},
				{%- endfor %}
			]
		},
		{%- for field in nonListObjectFields %}
		{
			value: '{{ field.fieldName }}',
			label: $LL.graphql.objects.{{ name }}.fields.{{ field.fieldName }}.name(),
			options: [
				{%- for leafField in field.leafFieldList %}
				{
					value: '{{ leafField.fieldName }}',
					label: $LL.graphql.objects.{{ name }}.fields.{{ field.fieldName }}.name() + $LL.graphql.objects.{{ field.fieldTypeName }}.fields.{{ leafField.fieldName }}.name(),
					{%- if useAuth %}
					disabled: !permissions.auth('{{ field.fieldTypeName }}::{{ leafField.fieldName }}::READ')
					{%- endif %}
				},
				{%- endfor %}
			],
			{%- if useAuth %}
			disabled: !permissions.auth('{{ name }}::{{ field.fieldName }}::READ')
			{%- endif %}
		},
		{%- endfor %}
	];

	let filteredSelectOptions = selectOptions;

	$: joinOptions = [
		{%- for field in listObjectFields %}
		{
			value: '{{ field.fieldName }}',
			label: $LL.graphql.objects.{{ name }}.fields.{{ field.fieldName }}.name(),
			options: [
				{%- for leafField in field.leafFieldList %}
				{
					value: '{{ leafField.fieldName }}',
					label: $LL.graphql.objects.{{ name }}.fields.{{ field.fieldName }}.name() + $LL.graphql.objects.{{ field.fieldTypeName }}.fields.{{ leafField.fieldName }}.name(),
					{%- if useAuth %}
					disabled: !permissions.auth('{{ field.fieldTypeName }}::{{ leafField.fieldName }}::READ')
					{%- endif %}
				},
				{%- endfor %}
			],
			{%- if useAuth %}
			disabled: !permissions.auth('{{ name }}::{{ field.fieldName }}::READ')
			{%- endif %}
		},
		{%- endfor %}
	];

	let filteredJoinOptions =
		joinOptions?.map((option) => ({
			value: option.value,
			label: option.label,
			disabled: option.disabled
		})) || [];

	$: joinColumnOptions = join
		? joinOptions.find((option) => option.value === join?.value)?.options
		: [];

	let filteredJoinColumnOptions = joinColumnOptions;

	if (fields && fields.length > 0) {
		selectColumns = fields.flatMap((field) => {
			if (field.fields && field.fields.length > 0) {
				return selectOptions
					.filter((group) => group.value === field.name)
					.flatMap((group) =>
						field.fields!.flatMap((subField) =>
							group.options
								.filter((option) => option.value === subField.name)
								.map((option) => ({ ...option, group: { value: group.value, label: group.label } }))
						)
					);
			} else {
				return selectOptions
					.filter((group) => !group.value)
					.flatMap((group) =>
						group.options
							.filter((option) => option.value === field.name)
							.map((option) => ({ ...option, group: { value: group.value, label: group.label } }))
					);
			}
		});
	}

	$: selectColumns.reduce((groups, option) => {
			if (
				groups.some(
					(group) => group.value === option.group?.value && group.label === option.group?.label
				)
			) {
				groups
					.find(
						(group) => group.value === option.group?.value && group.label === option.group?.label
					)
					?.options?.push(option);
			} else {
				groups.push({
					value: option.group?.value,
					label: option.group?.label,
					options: [option]
				});
			}
			return groups;
		}, <G[]>[])
		.map((group) => {
			return {
				value: group.value,
				label: group.label,
				options: group.options?.flatMap((option) => [
					{ value: option.value, label: option.label + $LL.uiGraphql.table.th.asc(), node: 'ASC' },
					{ value: option.value, label: option.label + $LL.uiGraphql.table.th.desc(), node: 'DESC' }
				])
			};
		});

	$: orderByOptions = selectColumns.reduce((groups, option) => {
			if (
				groups.some(
					(group) => group.value === option.group?.value && group.label === option.group?.label
				)
			) {
				groups
					.find(
						(group) => group.value === option.group?.value && group.label === option.group?.label
					)
					?.options?.push(option);
			} else {
				groups.push({
					value: option.group?.value,
					label: option.group?.label,
					options: [option]
				});
			}
			return groups;
		}, <G[]>[])
		.map((group) => {
			return {
				value: group.value,
				label: group.label,
				options: group.options?.flatMap((option) => [
					{ value: option.value, label: option.label + $LL.uiGraphql.table.th.asc(), node: 'ASC' },
					{ value: option.value, label: option.label + $LL.uiGraphql.table.th.desc(), node: 'DESC' }
				])
			};
		});

	let filteredOrderByOptions = orderByOptions;

	$: if (queryArguments.orderBy && Object.keys(queryArguments.orderBy).length > 0) {
		orderByColumns = Object.entries(queryArguments.orderBy).flatMap((entry) => {
			if (entry[1] === 'ASC' || entry[1] === 'DESC') {
				return orderByOptions.flatMap((group) =>
					(group.options || [])
						.filter((option) => option.value === entry[0] && option.node === entry[1])
						.map((option) => ({ ...option, group: group }))
				);
			} else {
				return Object.entries(entry[1] || {}).flatMap((subEntry) =>
					orderByOptions
						.filter((group) => group.value === entry[0])
						.flatMap((group) =>
							(group.options || [])
								.filter((option) => option.value === subEntry[0] && option.node === subEntry[1])
								.map((option) => ({ ...option, group: group }))
						)
				);
			}
		});
	}

	if (queryArguments.first) {
		pageSize = queryArguments.first;
	}

	if (queryArguments.offset) {
		pageNumber = queryArguments.offset / pageSize + 1;
	}

	const optionsToFields = (): Field[] => {
		return [
			...selectColumns.reduce((fields, option) => {
				if (option.group?.value) {
					if (fields.some((field) => field.name === option.group?.value)) {
						fields
							.find((field) => field.name === option.group?.value)
							?.fields?.push({ name: option.value });
					} else {
						fields.push({
							name: option.group.value,
							fields: [{ name: option.value }]
						});
					}
				} else {
					fields.push({ name: option.value });
				}
				return fields;
			}, <Field[]>[]),
			...(join && joinColumns && joinColumns.length > 0
				? [{ name: join.value, fields: joinColumns?.map((column) => ({ name: column.value })) }]
				: [])
		];
	};

	const buildFields = (): Field[] => {
		fields = optionsToFields();
		return fields;
	};

	const buildQueryFields = (): Field[] => {
		queryFields = optionsToFields().map((field) => {
			if (field.fields) {
				const idFieldName = getIdFieldName(typeName, field.name);
				if (!field.fields.some((subField) => subField.name === idFieldName)) {
					field.fields.push({ name: idFieldName! });
				}
			}
			return field;
		});

		if (!queryFields.some((subField) => subField.name === '{{ idName }}')) {
			queryFields.push({ name: '{{ idName }}' });
		}

		return queryFields;
	};

	const buildArguments = (toPageNumber?: number | undefined): {{ name }}ConnectionQueryArguments => {
		if (!queryArguments) {
			queryArguments = {};
		}

		if (orderByColumns.length > 0) {
			queryArguments.orderBy = Object.fromEntries(
				orderByColumns
					.reduce((groups, option) => {
						if (groups.some((group) => group.value === option.group?.value)) {
							groups
								.find((group) => group.value === option.group?.value)
								?.sorts?.push({ value: option.value, sort: option.node });
						} else {
							if (option.group?.value) {
								groups.push({
									value: option.group?.value,
									sorts: [{ value: option.value, sort: option.node }]
								});
							} else {
								groups.push({
									value: option.value,
									sort: option.node
								});
							}
						}
						return groups;
					}, <{ value: string; sort?: string; sorts?: { value: string; sort: string }[] }[]>[])
					.map((sort) => {
						if (sort.sorts) {
							return [
								sort.value,
								Object.fromEntries(sort.sorts?.map((sort) => [sort.value, sort.sort]))
							];
						} else {
							return [sort.value, sort.sort];
						}
					})
			);
		} else {
			queryArguments.orderBy = undefined;
		}

		queryArguments.offset = ((toPageNumber || pageNumber) - 1) * pageSize;
		queryArguments.first = pageSize;
		return queryArguments;
	};

	export const getFieldName = (fieldName: string, subFieldName?: string): string => {
		if (subFieldName) {
			return [...selectOptions, ...joinOptions]
				.filter((group) => group.value === fieldName)
				?.flatMap((group) => group.options.filter((option) => option.value === subFieldName))[0]
				.label;
		} else {
			return (
				[...selectOptions, ...joinOptions]
					.filter((group) => !group.value)
					?.flatMap((group) => group.options.filter((option) => option.value === fieldName))?.[0] ||
				[...selectOptions, ...joinOptions].find((group) => group.value === fieldName)
			).label;
		}
	};

	const queryPage = (toPageNumber?: number | undefined) => {
		buildFields();
		dispatch('query', { fields: buildQueryFields(), queryArguments: buildArguments(toPageNumber) });
	};

	queryPage();
</script>

{#if showHeader}
	<div class="flex space-x-1">
		<Combobox
			title={$LL.{{ appName }}.components.query.columns()}
			multiple={true}
			groups={filteredSelectOptions}
			rootClassName="w-full"
			bind:value={selectColumns}
			on:search={(e) => {
				if (e.detail.searchValue) {
					filteredSelectOptions = selectOptions
						.filter(
							(group) =>
								group.label.includes(e.detail.searchValue || '') ||
								group.options.some((option) => option.label.includes(e.detail.searchValue || ''))
						)
						.map((group) => ({
							...group,
							options: group.options.filter((option) =>
								option.label.includes(e.detail.searchValue || '')
							)
						}));
				} else {
					filteredSelectOptions = selectOptions;
				}
			}}
			on:change={(e) => {
				orderByColumns = orderByColumns.filter(
					(orderColumn) =>
						!Array.isArray(e.detail.value) ||
						e.detail.value.some((selectColumn) => selectColumn.value === orderColumn.value)
				);
				queryPage(1);
			}}
		/>
		{#if showOptionButton}
			<div class="tooltip" data-tip={$LL.{{ appName }}.components.query.option()}>
				<button class="btn btn-square" use:melt={$trigger}>
					<Icon src={AdjustmentsHorizontal} class="h-5 w-5" />
				</button>
			</div>
			{#if $open}
				<div use:melt={$overlay} class="fixed inset-0 z-[50]" />
				<div
					class="space-y-2 md:space-y-1 p-1 rounded-xl bg-base-200 shadow z-[50]"
					use:melt={$content}
				>
					<div use:melt={$arrow} />
					<div class="space-y-1" transition:fade={% raw %}{{{% endraw %} duration: 100 {% raw %}}}{% endraw %}>
						<Combobox
							title={$LL.graphence.components.query.join()}
							options={filteredJoinOptions}
							rootClassName="w-full"
							className="md:input-xs"
							containerClassName="md:min-h-8 max-w-xs"
							tagClassName="md:badge-sm"
							groupClassName="md:input-group-sm"
							bind:value={join}
							on:search={(e) => {
								if (e.detail.searchValue) {
									filteredJoinOptions =
										joinOptions
											?.filter((group) => group.label?.includes(e.detail.searchValue || ''))
											.map((option) => ({
												value: option.value,
												label: option.label,
												disabled: option.disabled
											})) || [];
								} else {
									filteredJoinOptions =
										joinOptions?.map((option) => ({
											value: option.value,
											label: option.label,
											disabled: option.disabled
										})) || [];
								}
							}}
							on:change={(e) => {
								queryPage(1);
							}}
						/>
						<Combobox
							title={$LL.graphence.components.query.joinColumns()}
							multiple={true}
							options={filteredJoinColumnOptions}
							rootClassName="w-full"
							className="md:input-xs"
							containerClassName="md:min-h-8 max-w-xs"
							tagClassName="md:badge-sm"
							groupClassName="md:input-group-sm"
							bind:value={joinColumns}
							on:search={(e) => {
								if (e.detail.searchValue) {
									filteredJoinColumnOptions = joinColumnOptions?.filter((option) =>
										option.label?.includes(e.detail.searchValue || '')
									);
								} else {
									filteredJoinColumnOptions = joinColumnOptions;
								}
							}}
							on:change={(e) => {
								queryPage(1);
							}}
						/>
						<Combobox
							title={$LL.{{ appName }}.components.query.orderBy()}
							multiple={true}
							groups={filteredOrderByOptions}
							rootClassName="w-full"
							className="md:input-xs"
							containerClassName="md:min-h-8 max-w-xs"
							tagClassName="md:badge-sm"
							groupClassName="md:input-group-sm"
							bind:value={orderByColumns}
							on:search={(e) => {
								if (e.detail.searchValue) {
									filteredOrderByOptions = orderByOptions
										.filter(
											(group) =>
												group.label?.includes(e.detail.searchValue || '') ||
												group.options?.some((option) =>
													option.label.includes(e.detail.searchValue || '')
												)
										)
										.map((group) => ({
											...group,
											options: group.options?.filter((option) =>
												option.label.includes(e.detail.searchValue || '')
											)
										}));
								} else {
									filteredOrderByOptions = orderByOptions;
								}
							}}
							on:change={(e) => {
								queryPage(1);
							}}
						/>
					</div>
				</div>
			{/if}
		{/if}
		{#if showFilterButton}
			<{{ name }}Filter bind:expression={queryArguments} let:trigger on:filter={(e) => queryPage(1)}>
				<div class="tooltip" data-tip={$LL.{{ appName }}.components.query.filter()}>
					<button class="btn btn-square" use:melt={trigger}>
						<Icon src={Funnel} class="h-5 w-5" />
					</button>
				</div>
			</{{ name }}Filter>
		{/if}
		{#if showBookmarkButton}
			<div class="tooltip" data-tip={$LL.{{ appName }}.components.query.bookmark()}>
				<button
					class="btn btn-square"
					on:click={(e) =>
						dispatch('bookmark', {
							fields: JSON.stringify(buildFields()),
							queryArguments: JSON.stringify(buildArguments())
						})}
				>
					<Icon src={Bookmark} class="h-5 w-5" />
				</button>
			</div>
		{/if}
	</div>
	<div class="divider" />
{/if}
<div class="card-body overflow-auto {className}">
	{#if isFetching}
		<div class="flex justify-center">
			<span class="loading loading-bars loading-lg" />
		</div>
	{:else}
		<slot {getFieldName} />
	{/if}
</div>
{#if showFooter}
	<div class="divider" />
	<Pagination
		bind:pageNumber
		bind:pageSize
		{totalCount}
		on:pageChange={(e) => queryPage()}
		on:sizeChange={(e) => queryPage()}
	/>
{/if}
